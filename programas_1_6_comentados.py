# -*- coding: utf-8 -*-
"""Programas 1-6_comentados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Auu48n0N8yzgnhVBIir3-HOTbiEYm-g4

# Tarea 1
"""

"""--- Programa para calcular la distancia entre 2 puntos ---"""

import math
# Se importa la libreria math para poder realizar la operación de raiz cuadrada 'sqrt'
def distancia():
  # Con 'def' se inicializa una función de nombre 'distancia' la cual no recibe parámetros '()'
  x1,x2,y1,y2 = input('Ingresa en este orden los valores enteros de x1,x2,y1,y2:').split()
  # Con '.split()" podemos asignar los valores a x1,x2,y1,y2 en una sola linea separandolos por espacios'
  x1,x2,y1,y2 = int(x1), int(x2), int(y1), int(y2)
  # En una misma linea cambiamos el valor de cada variable de 'str' a 'int'
  suma = float(((x2-x1)**2) + ((y2-y1)**2))
  # Guardamos en la variable 'suma' esta operación y le asignamos el tipo de dato 'float' al resultado
  print(f'distancia={math.sqrt(suma):.2f}')
  # Imprimimos con un f-string: 'distancia={math.sqrt(suma):.2f}'
  # Siendo lo que está dentro del corchete la raiz cuadrada de suma 'math.sqrt(suma)'
  # Mostrando 2 decimales en el resultado ':.2f'
  """print(f'distancia={math.sqrt(suma)}')"""
  # De esta manera imprimiriamos el resultado de la raiz cuadrada con muchos decimales
  # Pero para mejor formato solo se imprimen 2


distancia()
# LLamamos a la función para que se realice todas las instrucciones dentro de la misma

"""--- Ejemplo de ejecución ---"""
# Ingresa en este orden los valores enteros de x1,x2,y1,y2:1 2 3 4
# distancia=1.41

"""# Tarea 2

"""

"""--- Programa para convertir unidades imperiales a centímetros ---"""

opcion = input("Qué conversión desea realizar: \n(1) para pies a cm \n(2) para pulgadas a cm \n(3) para yardas a cm\n")
# Con 'input()' le solicitamos al usuario que ingrese una opción
# Usando saltos de linea '\n' para un mejor formato
# El valor ingresado se guarda en la variable 'opcion'

opcion = int(opcion)
# Convertimos el tipo de dato de 'opcion' de 'str' a un 'int'

def pies_cm(pies): return pies*30.48
# Se define una función llamada 'pies_cm' que toma un parámetro 'pies'
# La función retorna el valor de 'pies' multiplicado por el factor de conversión (30.48 cm/pie)

def pulgadas_cm(pulgadas): return pulgadas*2.54
# Se define la función 'pulgadas_cm' que toma 'pulgadas' y retorna su valor en centímetros (factor 2.54 cm/pulgada)

def yardas_cm(yardas): return yardas*91.44
# Se define una función llamada 'yardas_cm' que toma 'yardas' y retorna su valor en centímetros (factor 91.44 cm/yarda)

match opcion:
# Se inicia la estructura de control 'match-case' que evalua el valor de 'opcion'

  case 1:
# Si el valor de 'opcion' es 1, se ejecuta el siguiente código para convertir pies a cm.
    pies = input("Ingrese el numero de pies:")
    # Se pide al usuario que ingrese el número de pies a convertir y se guarda en 'pies' como str
    pies = int(pies)
    # Convertimos el tipo de dato de 'pies' de 'str' a un 'int'
    if pies <= 0:
    # Se verifica si el número de pies es menor o igual a cero con 'if'
      print("Error")
      # Si la condición es verdadera se imprime "Error"
    else:
    # Si el valor es positivo
      print(f"{pies} pies son equivalentes a:{pies_cm(pies):.2f} cm")
      # Se imprime el resultado de la conversión usando un f-string
      # Se llama a la función pasandole 'pies' 'pies_cm(pies)' y se imprime el resultado a dos decimales con ':.2f'

  case 2:
# Si el valor de 'opcion' es 2, se ejecuta el siguiente código para convertir pulgadas a cm
    pulgadas = input("Ingrese el numero de pulgadas:")
    # Se pide al usuario el número de pulgadas.
    pulgadas = int(pulgadas)
    # El valor de 'pulgadas' se convierte a entero.
    if pulgadas <= 0:
    # Se verifica si el número de pulgadas es menor o igual a cero con 'if'
      print("Error")
      # Si la condición es verdadera se imprime "Error"
    else:
    # Si el valor es positivo
      print(f"{pulgadas} pulgadas son equivalentes a:{pulgadas_cm(pulgadas):.2f} cm")
      # Se imprime el resultado de la conversión usando un f-string
      # Se llama a la función pasandole 'pulgadas' 'pulgadas_cm(pulgadas)' y se imprime el resultado a dos decimales con ':.2f'

  case 3:
# Si el valor de 'opcion' es 3, se ejecuta el siguiente código para la conversión de yardas a cm
    yardas = input("Ingrese el numero de yardas:")
    # Se pide al usuario el número de yardas
    yardas = int(yardas)
    # El valor de 'yardas' se convierte a entero.
    if yardas <= 0:
    # Se verifica si el número de yardas es menor o igual que 0
      print("Error")
      # Si la condición es verdadera se imprime "Error"
    else:
    # Si el valor es positivo
      print(f"{yardas} yardas son equivalentes a:{yardas_cm(yardas):.2f} cm")
      # Se imprime el resultado de la conversión usando un f-string
      # Se llama a la función pasandole 'yardas' 'yardas_cm(yardas)' y se imprime el resultado a dos decimales con ':.2f'

  case _:
# Si 'opcion' no coincide con ninguno de los casos anteriores (1, 2, 3)
    print("ERROR")
    # Se imprime "ERROR"


"""--- Ejemplo de ejecución ---"""
# Qué conversión desea realizar:
# (1) para pies a cm
# (2) para pulgadas a cm
# (3) para yardas a cm
# 1
# Ingrese el numero de pies: 35
# 35 pies son equivalentes a:1066.80 cm

"""# Tarea 3"""

"""--- Programa que toma un pedido y muestra el total de tu compra ---"""

pedido_total = 0
# Inicializa la variable 'pedido_total' para acumular el costo, comenzando en cero

decision = 1
# Inicializa la variable 'decision' en 1 para que el bucle 'while' comience

print(' Bienvenido al sistema de pedido a domicilio. \n--------------------\n1. Pizza - $10 \n2. Hamburguesa - $8 \n3. Ensalada - $7 \n0. Finalizar pedido\n--------------------')
# Imprime el menú de opciones con saltos de linea '\n' para un mejor formato

while decision != 0:
# Inicia un bucle 'while' que se ejecuta mientras 'decision' sea diferente de 0
  decision = input('Introduce el número de la opción que deseas: ')
  # Solicita al usuario que ingrese una opción y eso se guarda en 'decision'
  decision = int(decision)
  # Convierte 'decision' de string a entero

  match decision:
  # Inicia la estructura de control 'match-case' para evaluar la 'decision'
    case 0:
    # Si la decisión es 0 (Finalizar pedido)
      break
      # Se interrumpe el bucle 'while'
    case 1:
    # Si la decisión es 1 (Pizza)
      pedido_total += 10
      # Se suma 10 (costo de la pizza) al 'pedido_total'
      print(f'Añadiste Pizza a tu pedido. Total actual: ${pedido_total}')
      # Muestra un mensaje de confirmación y el total acumulado hasta el momento
      # El bucle se regresa a la linea que pide al usuario que ingrese el número de la opción que desee
    case 2:
    # Si la decisión es 2 (Hamburguesa)
      pedido_total += 8
      # Suma 8 al 'pedido_total'
      print(f'Añadiste Hamburgesa a tu pedido. Total actual: ${pedido_total}')
       # Muestra un mensaje de confirmación y el total acumulado hasta el momento
       # El bucle se regresa a la linea que pide al usuario que ingrese el número de la opción que desee
    case 3:
    # Si la decisión es 3 (Ensalada)
      pedido_total += 7
      # Suma 7 al 'pedido_total'
      print(f'Añadiste Ensalada a tu pedido. Total actual: ${pedido_total}')
      # Muestra un mensaje de confirmación y el total acumulado hasta el momento
      # El bucle se regresa a la linea que pide al usuario que ingrese el número de la opción que desee
    case _:
    # Si 'decision' no coincide con 0, 1, 2 o 3
      print('error, intentar nuevamente')
      # Imprime un mensaje de error

print(f' El total de su pedido es: ${pedido_total}\n Gracias por su pedido. ¡Buen provecho!')
# Una vez fuera del bucle 'while', imprime el total final del pedido y un mensaje de despedida con f-string

"""--- Ejemplo de ejecución ---"""
# Bienvenido al sistema de pedido a domicilio.
# --------------------
# 1. Pizza - $10
# 2. Hamburguesa - $8
# 3. Ensalada - $7
# 0. Finalizar pedido
# --------------------
# Introduce el número de la opción que deseas: 1
# Añadiste Pizza a tu pedido. Total actual: $10
# Introduce el número de la opción que deseas: 2
# Añadiste Hamburgesa a tu pedido. Total actual: $18
# Introduce el número de la opción que deseas: 2
# Añadiste Hamburgesa a tu pedido. Total actual: $26
# Introduce el número de la opción que deseas: 0
#  El total de su pedido es: $26
#  Gracias por su pedido. ¡Buen provecho!

"""--- Programa que calcula el promedio de tiempo en redes sociales ---"""

t_horas = [2, 1.5, 2.5, 3, 1, 4,]
# Se inicializa una lista llamada 't_horas' con valores tipo 'float' y 'int'
# Que representan los tiempos en horas

def t_promedio(lista_con_horas):
# Se define una función llamada 't_promedio' que toma como un argumento:
# una lista de números
  promedio = sum(lista_con_horas)/len(lista_con_horas)
  # Dentro de la función, se calcula el promedio del tiempo en horas
  # 'sum()' suma todos los elementos de la lista y 'len()' obtiene el número de elementos
  # El resultado de la división (suma/cantidad) se guarda en 'promedio'
  return promedio
  # La función retorna el valor calculado del promedio

print(f'El tiempo promedio diario en redes sociales es de {t_promedio(t_horas):.2f} horas')
# Se imprime el resultado del tiempo promedio en horas
# Se llama a la función 't_promedio' pasando la lista 't_horas' como argumento
# Se usa un f-string y se muestra el resultado a dos decimales ':.2f'

conversion_anonima = lambda x: x*60
# Se define una función anónima (lambda) que toma un argumento 'x'
# Esta función retorna el valor de 'x' multiplicado por 60,
# Se usará más adelante para convertir horas a minutos

print(f'El tiempo promedio diario en redes sociales es de {conversion_anonima(t_promedio(t_horas)):.2f} minutos por día.')
# Se imprime el resultado del tiempo promedio en minutos por día
# Se llama a 't_promedio(t_horas)' para obtener el promedio en horas
# Luego, ese resultado se pasa inmediatamente a la función lambda 'conversion_anonima' para convertirlo a minutos
# Para el resultado final se usa un f-string y se muestra el resultado a dos decimales ':.2f'

"""--- Ejemplo de ejecución ---"""
# El tiempo promedio diario en redes sociales es de 2.33 horas
# El tiempo promedio diario en redes sociales es de 140.00 minutos por día.

"""# Tarea 4"""

"""--- Analizador de una lista entera (todo-en-uno de una sola lista) ---"""

nums = []
# Se crea una lista vacía llamada 'nums' que almacenará los números ingresados

k = int(input('Cuantos elementos quieres en la lista?: '))
# Pide al usuario el número de elementos que tendrá la lista
# La entrada se guarda como 'int' en 'k'

for i in range(k):
# Se inicia un bucle 'for' que itera desde 0 hasta k-1, con pasos de 1
# Esto para pedir k veces (0-k-1) un numero al usuario
  a = int(input(f'Ingresa el {i+1}° numero: '))
  # Se pide al usuario que ingrese un número
  # usando f-string para indicar qué número se está pidiendo
  # Y como se inicia en 0 se le suma 1 a 'i' para iniciar en 1
  # La entrada se convierte a 'int' y se guarda en 'a'
  nums.append(a)
  # Se ñade el número 'a' al final de la lista 'nums'
  # El bucle se repite hasta que se haya llegado a k-1

print(f'Tu lista es:{nums}')
# Imprime la lista que ha sido creada como f-string

for numeros in nums:
# Inicia un bucle 'for' que itera sobre cada elemento de la lista 'nums'
  print(f'nums[{nums.index(numeros)}] = {numeros}')
  # Imprime cada elemento mostrando su índice y su valor como f-string

print('\nEn orden inverso: ')
# Se imprime un salto de línea y el encabezado 'En orden inverso:'
# Para indicar que lo siguiente va a ser la lista en orden inverso

n = -1
# Inicializa un contador 'n' en -1
# El cual representa el índice del último elemento

for numeros in nums:
# Se inicia un bucle 'for' para iterar sobre la lista
  print(f'nums[{n}] = {nums[n]}')
  # Imprime el valor de la lista usando el índice negativo 'n'
  n -= 1
  # Hacemos que decrezca el valor de 'n' en 1 para moverse al penúltimo, antepenúltimo, etc

print('\nPromedio: ')
# Imprime un salto de línea y un encabezado para la sección de promedio

promedio = float(sum(nums)/len(nums))
# Se calcula el promedio: 'sum(nums)' que suma todos los elementos entre 'len(nums)', el total de elementos
# El resultado se convierte a 'float' y se guarda en 'promedio'

print(f'El promedio de la lista es: {promedio}')
# Imprime el promedio como f-string

print('\nCuenta de pares e impares: ')
# Imprime un salto de línea y un encabezado para la sección de conteo

par = 0
# Inicializamos un contador para números pares en 0

impar = 0
# Inicializamos otro contador para números impares en 0

for numero in nums:
# Inicia un bucle 'for' para iterar sobre cada 'numero' en la lista 'nums'
  if numero % 2 == 0:
  # Se verifica  con 'if' si el número es par usando módulo (%)
  # Si el residuo de la división entre 2 es 0, el número es par
    par +=1
    # Incrementa el contador 'par'
  else:
  # Si la condición no se cumple (el residuo no es 0)
    impar +=1
    # Aumentamos en 1 el contador 'impar'

print(f'Pares =  {par}')
# Imprime el conteo final de números pares

print(f'Impares =  {impar}')
# Imprime el conteo final de números impares


print('\nLista al cuadrado: ')
# Imprimimos otro encabezado para la siguiente sección

nums_pares = []
# Inicializamos una lista vacía para almacenar números pares

nums_impares = []
# Inicializamos otra lista vacía para almacenar números impares

nums_cuadrados = []
# Inicializamos otra lista vacía para almacenar los números al cuadrado

for numero in nums:
# Inicia un bucle 'for' que itera sobre cada 'numero' en la lista original 'nums'
# En este ciclo iteramos para obtener de un solo 'for':
# Los impares, pares y el resultado de elevar al cuadrado cada numero de la lista
  numero_cuadrado = numero**2
  # Calcula el cuadrado del número y lo guarda en 'numero_cuadrado'
  nums_cuadrados.append(numero_cuadrado)
  # Añade el cuadrado a la lista 'nums_cuadrados'
  if numero % 2 == 0:
  # Verifica si el número es par
    nums_pares.append(numero)
    # Si es par, lo añade a 'nums_pares'
  else:
  # Si es impar
    nums_impares.append(numero)
    # Lo añade a 'nums_impares'

print(nums_cuadrados)
# Imprime la lista de todos los números elevados al cuadrado

print(f'\nSublista de pares: {nums_pares}')
# Imprime la sublista que contiene solo los números pares como f-string

print(f'\nSublista de impares: {nums_impares}')
# Imprime la sublista que contiene solo los números impares como f-string

###########################################################
print('\nValores menores que su siguiente: ')
# Se imprime el encabezado para la última sección

for i in range(1,k):
# Inicia un bucle 'for' que itera desde el índice 1 hasta el final de la lista (k-1)
# El índice 0 se omite porque se compara con el elemento anterior (i-1)
# Como el primer elemento (índice 0) no tiene uno anterior se omite
# y entonces se empieza por el segundo elemento (índice 1)
  if nums[i-1] < nums[i]:
  # Compara el elemento actual (nums[i]) con el elemento anterior (nums[i-1])
  # Si el elemento anterior es menor que el actual
    print(nums[i-1])
    # Imprime el elemento anterior

"""--- Ejemplo de ejecución ---"""
# Cuantos elementos quieres en la lista?: 5
# Ingresa el 1° numero: 9
# Ingresa el 2° numero: 4
# Ingresa el 3° numero: 3
# Ingresa el 4° numero: 5
# Ingresa el 5° numero: 7
# Tu lista es:[9, 4, 3, 5, 7]
# nums[0] = 9
# nums[1] = 4
# nums[2] = 3
# nums[3] = 5
# nums[4] = 7
#
# En orden inverso:
# nums[-1] = 7
# nums[-2] = 5
# nums[-3] = 3
# nums[-4] = 4
# nums[-5] = 9
#
# Promedio:
# El promedio de la lista es: 5.6
#
# Cuenta de pares e impares:
# Pares =  1
# Impares =  4
#
# Lista al cuadrado:
# [81, 16, 9, 25, 49]
#
# Sublista de pares: [4]
#
# Sublista de impares: [9, 3, 5, 7]
#
# Valores menores que su siguiente:
# 3
# 5

"""--- Dúo de listas: suma por posición, ordenación y sin duplicados ---"""

nums1 = []
# Se inicializa la primera lista vacía para guardar números

nums2 = []
# Se inicializa la segunda lista vacía para guardar números

n_de_nums = int(input('Cuantos numeros quieres por lista?: '))
# Se pide al usuario la cantidad de números que contendrá cada lista
# Se guarda el valor en 'n_de_nums' y se convierte a 'int'

for i in range(n_de_nums):
# Se inicializa un 'for' para llenar la primera lista, iterando 'n_de_nums' veces
  numero = int(input(f'Ingresa el {i+1}° numero de la "PRIMER" lista: '))
  # Por cada iteración se le pide al usuario un numero
  # La entrada se convierte a entero 'int'
  # Como se inicia por 0, se le suma 1 a 'i' para un mejor formato
  nums1.append(numero)
  # El número ingresado se añade al final de la lista 'nums1'

for i in range(0,n_de_nums):
# Se inicializa un 'for' para llenar la segunda lista, iterando 'n_de_nums' veces
  numero = int(input(f'Ingresa el {i+1}° numero de la "SEGUNDA" lista: '))
  # Se pide el número para la segunda lista
  nums2.append(numero)
  # El número se añade al final de la lista 'nums2'

print(f'L1= {nums1}')
# Se imprime la primera lista creada como f-string

print(f'L2= {nums2}')
# Se imprime la segunda lista creada como f-string

############### SUMA
lsuma = []
# Se crea una lista vacía para almacenar las sumas de los elementos

for i in range(n_de_nums):
# Bucle para iterar a través de los índices de ambas listas,
# Pues tienen el mismo numero de valores
  suma = nums1[i]+nums2[i]
  # Se suman los elementos que tienen el mismo índice 'i' en 'nums1' y 'nums2'
  lsuma.append(suma)
  # El resultado de la suma se añade a la lista 'lsuma'

print(f'LSUMA= {lsuma}')
# Se imprime la lista resultante de las sumas

################ ORDENADA
lunida = []
# Se inicializa una lista vacía que contendrá los elementos de ambas listas

for num in nums1:
# Bucle para iterar sobre todos los elementos de 'nums1'
  lunida.append(num)
  # Cada elemento de 'nums1' se añade a 'lunida'

for num in nums2:
# Bucle para iterar todos los elementos de 'nums2'
  lunida.append(num)
  # Cada elemento de 'nums2' se añade a 'lunida'
  # La cual ya tiene los elementos de la lista 1

lunida.sort()
# Se ordena la lista 'lunida' en orden ascendente con 'sort()'

print(f'LORDENADA= {lunida}')
# Se imprime la lista resultante con los elementos ordenados

################ UNICA
for i in range(0,n_de_nums+1):
# Bucle para encontrar duplicados, iterando n_de_nums veces
  repeticiones = lunida.count(lunida[i])
  # Se va iterando en los índices de lunida,
  # Si un valor solo se encuentra una vez, entonces repeticiones = 1
  # Pero si un valor se encuentra más de una vez, entonces repeticiones > 1

  if repeticiones > 1:
  # Si el elemento está repetido (aparece más de una vez)
    lunida.remove(lunida[i])
    # Se elimina el elemento duplicado usando 'remove'

print(f'LUNICA= {lunida}')
# Se imprime la lista final con valores únicos

"""--- Ejemplo de ejecución ---"""
# Cuantos numeros quieres por lista?: 3
# Ingresa el 1° numero de la "PRIMER" lista: 5
# Ingresa el 2° numero de la "PRIMER" lista: 2
# Ingresa el 3° numero de la "PRIMER" lista: 8
# Ingresa el 1° numero de la "SEGUNDA" lista: 2
# Ingresa el 2° numero de la "SEGUNDA" lista: 1
# Ingresa el 3° numero de la "SEGUNDA" lista: 5
# L1= [5, 2, 8]
# L2= [2, 1, 5]
# LSUMA= [7, 3, 13]
# LORDENADA= [1, 2, 2, 5, 5, 8]
# LUNICA= [1, 2, 5, 8]

"""--- Menú de funciones: dígitos faltantes, Fibonacci y combinación de strings ---"""

des = 'si'
# Se le da el valor 'si' a 'des' para iniciar el bucle while
while des == 'si':
# Inicia el bucle principal del programa que controla el menú
  decision_max = int(input('Ingresa el numero de la opcion que desees realizar \n1) Dígitos faltantes (1–9) \n2) Fibonacci en lista \n3) Combinar listas de strings \n4) Salir'))
  # Solicita al usuario elegir una opción del menú principal
  # La entrada se convierte a 'int' y se guarda en 'decision_max'

  match decision_max:
  # Evalúa el valor de la opción elegida (decision_max)
    case 1:
    # Si la opción es 1
      op1()
      # Llama a la función op1 (Dígitos faltantes)
    case 2:
    # Si la opción es 2
      op2()
      # Llama a la función op2 (Fibonacci)
    case 3:
    # Si la opción es 3
      op3()
      # Llama a la función op3 (Combinar listas)
    case 4:
    # Si la opción es 4
      break
      # Se interrumpe el ciclo while
    case _:
    # Cualquier otra cosa
      print('Opcion invalida, vuelva a intentarlo')
      # Imprime un mensaje de error
      # Se regresa al menu

  des = input('Si deseas continuar con el MENÚ PRINCIPAL ingresa "si", de lo contrario ingresa cualquier otra cosa')
  # Pide al usuario que ingrese 'si' para repetir el bucle del menú principal,
  # O para terminar definitivamente

#######################################################################################################################
# Opcion 1
def op1():
# Se define la función op1 para encontrar dígitos faltantes
  from functools import reduce
  # Se importa la función 'reduce' de la libreria 'functools'

  t = []
  # Se crea una lista vacia 't' para almacenar los números ingresados por el usuario

  while True:
  # Inicia un bucle para la entrada de números
  # Como True está por default, se inicia el ciclo
    nums = int(input('\nIngresa un entero de 0 - 10: '))
    # Pide al usuario un número y lo convierte a entero

    if nums < 0 or nums > 10:
    # Verifica si el número está fuera del rango solicitado (0 a 10)
      print('Numero fuera del rango, recuerda que tiene que ser del 0-10')
      # Si está fuera de rango, imprime un mensaje de error
    else:
      t.append(nums)
      # Si está dentro del rango, añade el número a la lista 't'

    des = input('Si deseas terminar teclea "salir"\nde lo contrario ingresa cualquier otra cosa')
    # Pregunta al usuario si desea terminar la entrada de números

    if des == 'salir':
      break
      # Si ingresa "salir", se interrumpe el bucle
    else:
      continue
      # Si ingresa cualquier otra cosa, salta al inicio del bucle para pedir otro número

  nums_faltantes = []
  # Inicializa una lista vacía para guardar los números faltantes (del 1 al 9)

  for i in range(1,10):
  # Itera a través de los números del 1 al 9
    if i not in t:
    # Si el número actual 'i' no se encuentra en la lista 't' ingresada por el usuario
      nums_faltantes.append(i)
      # Se añade a la lista de faltantes

    if nums_faltantes == [1,2,3,4,5,6,7,8,9]:
    # Si absolutamente todos los números del 1 al 9 faltan
      print('_')
      # Se imprime un guion bajo
      break
      # Termina el bucle 'for'

  a = reduce(lambda x,y: f'{x} {y}', nums_faltantes)
  # Se usa 'reduce' con una función anónima para concatenar los elementos de
  # 'nums_faltantes' en un solo string, separados por un espacio

  print(a)
  # Imprime el string resultante con los números faltantes separados por espacio

####################################################################################################
# Opcion 2
def op2():
# Se define la función op2 para imprimir n numeros de la serie de Fibonacci
  n = int(input('Ingresa la cantidad de numeros de fibonacci que quieres que aparezcan: '))
  # Pide al usuario la cantidad 'n' de numeros de Fibonacci y lo convierte a entero

  n +=1
  # Incrementa 'n' en 1 porque la función range() y el slicing en Python son exclusivos en el límite superior, y el bucle interno usa 'n'

  fibonacci = [0,1]
  # Se crea una lista con los 2 primeros números de la serie de Fibonacci

  if n >= 1 and n <= 2 :
  # Si el usuario pide 0 o 1 numeros
    print(fibonacci[0:n-1])
    # Imprime 0, 1 o 2 numeros de fibonacci según 'n'

  elif n>=3:
  # Si quiere 3 o mas numeros de fibonacci se inicia un bucle
    for i in range(1,n):
    # Itera desde el índice 1 hasta n-1
      x = fibonacci[i-1] + fibonacci[i]
      # Calcula el siguiente número de Fibonacci sumando los dos anteriores ya presentes en la lista
      fibonacci.append(x)
      # Añade el nuevo número a la lista
    print(fibonacci)
    # Imprime la lista mostrando n numeros de Fibonacci

  else:
  # Si n es menor que 1 (0 a los negativos0):
    print('Eror, solo puedes ingresar numeros naturales o 0')
    # Imprime un mensaje de error

########################################################################################################
# Opcion 3
def op3():
# Se define la función op3 para combinar listas de strings alternadamente
  L1 = []
  # Se crea la lista L1
  L2 = []
  # Se crea la lista L2

  n_datosL1 = int(input('Ingresa el numero de elementos para L1\n'))
  # Pide el número de elementos para L1
  n_datosL2 = int(input('Ingresa el numero de elementos para L2\n'))
  # Pide el número de elementos para L2

  if n_datosL1 > n_datosL2:
  # Compara las longitudes de las listas
    caso = 1
    # Caso 1: L1 es más larga
  elif n_datosL2 > n_datosL1:
    caso = 2
    # Caso 2: L2 es más larga
  elif n_datosL2 == n_datosL1:
    caso = 3
    # Caso 3: Ambas tienen igual longitud

  print('-----') # Una division solamente

  if n_datosL1 > 0 and n_datosL2 > 0:
  # Este es un filtro que, si para alguna de las listas el usuario pone '0'
  # O un negativo, no se realiza la operación de combinar dos listas
  # De lo contrario:
    for i in range(0,n_datosL1):
      datosL1 = input(f'Ingresa el {i+1}° dato de L1')
      # Pide la entrada de datos para L1
      L1.append(datosL1)
      # Añade el dato a L1
    print('-----')

    for i in range(0,n_datosL2):
      datosL2 = input(f'Ingresa el {i+1}° dato de L2 ')
      # Pide la entrada de datos para L2
      L2.append(datosL2)
      # Añade el dato a L2
    print('-----')

    print(L1)
    # Imprime la lista L1
    print(L2)
    # Imprime la lista L2

    L3 = []
    # Creamos la lista L3, donde se almacenará la combinación


    match caso:
    # Estructura 'match-case' para ejecutar cierto código dependiendo del caso (1,2 o 3)
      case 1:
      # L1 > L2
        for i in range(0,n_datosL2):
        # Itera hasta la longitud de la lista más corta (L2)
          L3.append(L1[i])
          # Se añade primeo un elemento de L1
          L3.append(L2[i])
          # Luego uno de L2
          ultimo_i = i+1
          # Se guarda el índice posterior al último elemento combinado
          # En 'ultimo_i'
          # Esto para que en la siguiente parte del codigo no empiece desde ese mismo que se quedó
          # Sino desde el siguiente

        for iter in range(ultimo_i,n_datosL1):
        # Itera desde el siguiente índice donde se detuvo hasta el final de L1
          L3.append(L1[iter])
          # Añade los elementos restantes de la lista más larga (L1)

      case 2:
      # L2 > L1
        for i in range(0,n_datosL1):
        # Itera solo hasta la longitud de la lista más corta (L1)
          L3.append(L1[i])
          # Se añade primeo un elemento de L1
          L3.append(L2[i])
          # Luego uno de L2
          ultimo_i = i+1
          # Se guarda el índice posterior al último elemento combinado
          # En 'ultimo_i'
          # Esto para que en la siguiente parte del codigo no empiece desde ese mismo que se quedó
          # Sino desde el siguiente

        for iter in range(ultimo_i,n_datosL2):
        # Itera desde el siguiente índice donde se detuvo hasta el final de L1
          L3.append(L2[iter])
          # Añade los elementos restantes de la lista más larga (L2)

      case 3:
      # Si L1 y L2 son de igual longitud
        for i in range(0,n_datosL1):
        # Itera hasta la longitud de una de las listas
        # No importa cual se elija pues da lo mismo
          L3.append(L1[i])
          # Se añade primeo un elemento de L1
          L3.append(L2[i])
          # Luego uno de L2

  else:
  # Si alguna de las longitudes de las listas es 0 o negativa
    print('Error')
    # Imprime un mensaje de error

  print(L3)
  # Se imprime la lista combinada L3

"""--- Ejemplo de ejecución ---"""

# Ingresa el numero de la opcion que desees realizar
# 1) Dígitos faltantes (1–9)
# 2) Fibonacci en lista
# 3) Combinar listas de strings
# 4) Salir3
# Ingresa el numero de elementos para L1
# 3
# Ingresa el numero de elementos para L2
# 4
#  -----
# Ingresa el 1° dato de L11
# Ingresa el 2° dato de L12
# Ingresa el 3° dato de L13
# -----
# Ingresa el 1° dato de L2 4
# Ingresa el 2° dato de L2 5
# Ingresa el 3° dato de L2 6
# Ingresa el 4° dato de L2 7
# -----
# ['1', '2', '3']
# ['4', '5', '6', '7']
# ['1', '4', '2', '5', '3', '6', '7']
# Si deseas continuar con el MENÚ PRINCIPAL ingresa "si", de lo contrario ingresa cualquier otra cosa

"""# Tarea 5"""

"""--- Programa par obtener la diagonal principal de una matriz cuadrada ---"""


# Llama a la función 'main' para iniciar la ejecución del programa
# NOTA: En Python, las funciones deben definirse antes de ser llamadas, o bien se debe definir 'main' primero
# En este código, la definición de 'main' está después de la llamada, lo cual puede generar un NameError

def main():
# Definimos la función principal del programa
  ren,col = (input('Ingresa un numero igual de renglones y columnas separados por espacios: ')).split()
  # Pide al usuario que ingrese el número de renglones y columnas separados por espacio usando '.split()
  # Esos valores se asignan a 'ren' y 'col' respectivamente

  ren,col = int(ren), int(col)
  # Convierte la variable 'ren' y 'col' a 'int'

  if ren != col:
  # Si el numero de renglones no es igual al número de columnas:
    print('Error, no es una matriz cuadrada')
    # Se imprime un mensaje de error indicando que no es cuadrada

  else:
  # Si el número de renglones y columnas son iguales (Una matriz cuadrada)
    leer(ren,col)
    # Llama a la función 'leer' para construir la matriz, pasando las dimensiones

def leer(ren,col):
# Definimos la función 'leer' que se encarga de llenar la matriz
  matriz = []
  # Creamos la lista principal 'matriz' la cual contendrá a 'filas'
  fila = []
  # Creamos la lista donde se guardará cada fila de la matriz

  for i in range(0,ren):
  # Bucle exterior que itera el número de renglones ('ren')
    for it in range(0,col):
    # Bucle interior que itera el número de columnas ('col')
      valor = int(input(f'Ingresa el {it+1}° valor de la {i+1} fila: '))
      # Pide al usuario que ingrese un valor, indicando la  columna y fila
      # La entrada se convierte a 'int' y se guarda en 'valor'
      fila.append(valor)
      # Añade el 'valor' ingresado a la lista 'fila'

    matriz.append(fila)
    # Una vez completado el bucle interior, se añade esa 'fila' a la 'matriz'
    fila = []
    # Se reinicializa la lista 'fila' para obtener la lista del siguiente renglón

  for fila in matriz:
  # Bucle para iterar por cada 'fila' en 'matriz'
    print(fila)
    # Imprime cada fila, mostrando la matriz completa al final del bucle

  diagonal_principal(matriz)
  # Llama a la función 'diagonal_principal', pasando la matriz creada como argumento
  return matriz
  # Retorna la matriz

def diagonal_principal(matriz):
# Definimos la última función 'diagonal_principal'
  vector_diagonal = []
  # Cramos una lista vacía para almacenar los elementos de la diagonal en forma de vector

  for fila in range(len(matriz)):
  # Bucle exterior que itera a través de los índices de los renglones
    for columna in range(len(matriz)):
    # Bucle interior que itera a través de los índices de las columnas
      if fila == columna:
      # Si su índice de fila es igual a su índice de columna
      # Significa que ese elemento está en la diagonal principal
        vector_diagonal.append(matriz[fila][columna])
        # Entonces se añade ses valor a 'vector_diagonal'

  print(f'El vector diagonal es: {vector_diagonal}')
  # Imprime la lista que contiene los elementos de la diagonal principal

main()

"""--- Ejemplo de ejecución ---"""
# Ingresa un numero igual de renglones y columnas separados por espacios: 3 3
# Ingresa el 1° valor de la 1 fila: 1
# Ingresa el 2° valor de la 1 fila: 2
# Ingresa el 3° valor de la 1 fila: 3
# Ingresa el 1° valor de la 2 fila: 4
# Ingresa el 2° valor de la 2 fila: 5
# Ingresa el 3° valor de la 2 fila: 6
# Ingresa el 1° valor de la 3 fila: 7
# Ingresa el 2° valor de la 3 fila: 8
# Ingresa el 3° valor de la 3 fila: 9
# [1, 2, 3]
# [4, 5, 6]
# [7, 8, 9]
# El vector diagonal es: [1, 5, 9]

"""--- Programa que obtiene los valores centrales de una matriz ---"""

def main2():
# Definimos la función principal del programa
  ren, col = input('Ingrese el numero de filas y columnas separados por espacios: ').split()
  # Pide al usuario que ingrese el número de filas y columnas separados por espacio usando '.split()
  # Esos valores se asignan a 'ren' y 'col' respectivamente

  ren,col = int(ren), int(col)
  # Convierte 'ren' y 'col' a 'int'

  leer2(ren,col)
  # Llama a la función 'leer2' para construir la matriz, pasando las dimensiones

def leer2(ren,col):
# Definimos la función 'leer2' que se encarga de llenar la matriz
  matriz = []
  # Creamos la 'matriz'
  fila = []
  # Creamos la lista donde se guardará cada fila de la matriz

  for i in range(0,ren):
  # Bucle exterior que itera a través del número de renglones ('ren')
    for it in range(0,col):
    # Bucle interior que itera a través del número de columnas ('col')
      valor = int(input(f'Ingresa el {it+1}° valor de la {i+1} fila: '))
      # Pide un valor para la posición actual y lo convierte a entero
      fila.append(valor)
      # Añade el valor a la lista 'fila'

    matriz.append(fila)
    # Cuando se termina el bucle interior, se añade fila a la 'matriz'
    fila = []
    # Se reinicializa la lista 'fila' a vacía para la siguiente iteración

  for fila in matriz:
  # Bucle para iterar a través de cada 'fila' dentro de la 'matriz'
    print(fila)
    # Imprime cada fila de la matriz

  centroMatriz(matriz,ren,col)
  # Llama a la función 'centroMatriz', pasando la matriz y sus dimensiones

def centroMatriz(matriz,ren,col):
# Definimos la función 'centroMatriz' que extrae los elementos centrales
  matrizSalida = []
  # Creamos la lista que guardará el vector de salida
  vector = []
  # Creamos una lista para almacenar los valores centrales de la matriz

  for lista in range(1,ren-1):
  # Bucle exterior que itera a través de las filas (renglones) centrales
  # Es decir, omite los bordes
    for columna in range(1,col-1):
    # Bucle interior que itera a través de las columnas centrales
    # Es decir, omite los bordes
      vector.append(matriz[lista][columna])
      # Añade el elemento de la matriz (que está en una fila y columna central) al 'vector'

  matrizSalida.append(vector)
  # Añade el 'vector' con los valores centrales a la lista 'matrizSalida'

  print(f'Los valores en el centro de la matriz son: {matrizSalida}')
  # Imprime la matriz que contiene los valores centrales de la matriz original

main2()
# Llama a la función 'main2' para iniciar la ejecución del programa

"""--- Ejemplo de ejecución ---"""

# Ingrese el numero de filas y columnas separados por espacios: 4 3
# Ingresa el 1° valor de la 1 fila: 1
# Ingresa el 2° valor de la 1 fila: 2
# Ingresa el 3° valor de la 1 fila: 3
# Ingresa el 1° valor de la 2 fila: 4
# Ingresa el 2° valor de la 2 fila: 5
# Ingresa el 3° valor de la 2 fila: 6
# Ingresa el 1° valor de la 3 fila: 7
# Ingresa el 2° valor de la 3 fila: 8
# Ingresa el 3° valor de la 3 fila: 9
# Ingresa el 1° valor de la 4 fila: 10
# Ingresa el 2° valor de la 4 fila: 11
# Ingresa el 3° valor de la 4 fila: 12
# [1, 2, 3]
# [4, 5, 6]
# [7, 8, 9]
# [10, 11, 12]
# Los valores en el centro de la matriz son: [[5, 8]]

"""--- Programa que intercambia dos rengoles x,y de una matriz ---"""

def main3():
# Definimos la función principal del programa
  ren, col = input('Ingresa el numero de renglones y columnas separados por espacios: ').split()
  # Pide al usuario que ingrese el número de filas y columnas separados por espacio usando '.split()
  # Esos valores se asignan a 'ren' y 'col' respectivamente

  ren, col = int(ren), int(col)
  # Convierte 'ren' y 'col' a 'int'

  leer3(ren,col)
  # Llama a la función 'leer3' para crear la matriz

def leer3(ren,col):
# Define la función 'leer3' que se encarga de llenar la matriz
  matriz = []
  # Creamos la 'matriz'
  fila = []
  # Creamos la lista donde se guardará cada fila de la matriz

  for i in range(ren):
  # Bucle exterior que itera a través de los renglones
    for it in range(col):
    # Bucle interior que itera a través de las columnas
      valor = int(input(f'Ingresa el {it+1}° valor de la {i+1} fila: '))
      # Pide un valor y lo convierte a 'int'
      fila.append(valor)
      # Añade el valor a la lista 'fila'

    # Al terminar el bucle interno:
    matriz.append(fila)
    # Añade la 'fila' completa a la 'matriz'
    fila = []
    # Reinicializa la lista 'fila' para el siguiente renglón

  for fila in matriz:
  # Bucle para iterar e imprimir cada renglón de la matriz original
    print(fila)

  cambiaRenglones(matriz)
  # Llama a la función 'cambiaRenglones', pasando la matriz creada

def cambiaRenglones(matriz):
# Definimos la función 'cambiaRenglones' para realizar el intercambio
  posicion1, posicion2 = (input('Ingresa los renglones que deseas cambiar separados por espacios')).split()
  # Pide al usuario dos números de renglón que desea intercambiar, separados por espacio

  posicion1 = int(posicion1) -1
  # Convierte el primer número a entero y le resta 1 para obtener el índice de Python (0)
  posicion2 = int(posicion2) -1
  # Convierte el segundo número a entero y le resta 1 para obtener el índice de Python (0)

  reserva = matriz[posicion1]
  # Guardamos el primer renglón (fila) en la variable 'reserva'

  matriz.insert(posicion1,matriz[posicion2])
  # Insertamos el renglón 2 en la posición (índice) del renglón 1
  # Esto duplica la fila en la posición 1 y mueve el renglón 1 original (ahora en la posición 1+1) hacia abajo

  matriz.pop(posicion2+1)
  # Elimina la copia del renglón 2 que quedó en su posición original, más una posición adicional por el 'insert' anterior

  matriz.insert(posicion2+1,reserva)
  # Inserta la 'reserva' (el renglón 1 original) en la posición donde solía estar el renglón 2

  matriz.pop(posicion1+1)
  # Elimina la copia del renglón 1 que quedó

  print('La matriz con los intercambios es:')
  # Un encabezado para el resultado

  for fila in matriz:
  # Se itera a través de los renglones de la matriz modificada
    print(fila)
    # Imprime cada renglón de la matriz final

main3()
# Llama a la función 'main3' para iniciar la ejecución del programa

"""--- Ejemplo de ejecución ---"""

# Ingresa el numero de renglones y columnas separados por espacios: 4 4
# Ingresa el 1° valor de la 1 fila: 1
# Ingresa el 2° valor de la 1 fila: 2
# Ingresa el 3° valor de la 1 fila: 3
# Ingresa el 4° valor de la 1 fila: 4
# Ingresa el 1° valor de la 2 fila: 5
# Ingresa el 2° valor de la 2 fila: 6
# Ingresa el 3° valor de la 2 fila: 7
# Ingresa el 4° valor de la 2 fila: 8
# Ingresa el 1° valor de la 3 fila: 9
# Ingresa el 2° valor de la 3 fila: 10
# Ingresa el 3° valor de la 3 fila: 11
# Ingresa el 4° valor de la 3 fila: 12
# Ingresa el 1° valor de la 4 fila: 13
# Ingresa el 2° valor de la 4 fila: 14
# Ingresa el 3° valor de la 4 fila: 15
# Ingresa el 4° valor de la 4 fila: 16
# [1, 2, 3, 4]
# [5, 6, 7, 8]
# [9, 10, 11, 12]
# [13, 14, 15, 16]
# Ingresa los renglones que deseas cambiar separados por espacios1 3
# La matriz con los intercambios es:
# [9, 10, 11, 12]
# [5, 6, 7, 8]
# [1, 2, 3, 4]
# [13, 14, 15, 16]